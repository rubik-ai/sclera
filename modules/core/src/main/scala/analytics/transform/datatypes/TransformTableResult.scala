/**
* Sclera - Core
* Copyright 2012 - 2020 Sclera, Inc.
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.scleradb.analytics.transform.datatypes

import scala.language.postfixOps

import com.scleradb.sql.expr.{ScalExpr, ScalOpExpr, TypeCast}
import com.scleradb.sql.expr.{ScalColValue, ScalValueBase, SqlNull, ColRef}
import com.scleradb.sql.expr.{SortExpr, SortAsc, NullsFirst}

import com.scleradb.sql.types.SqlType
import com.scleradb.sql.datatypes.Column
import com.scleradb.sql.exec.{ScalExprEvaluator, ScalTypeEvaluator}

import com.scleradb.sql.result.{TableResult, ScalTableRow, ExtendedTableRow}
import com.scleradb.sql.result.TableRowGroupIterator

import com.scleradb.analytics.transform.expr._
import com.scleradb.analytics.transform.objects.Transformer

sealed abstract class TransformTableResult extends TableResult {
    val evaluator: ScalExprEvaluator

    val transformOp: Transform
    val inputResult: TableResult

    // logical input - map from the logical input names to their types
    private val inTypes: Map[String, SqlType] = Map() ++
        transformOp.in.map { case (name, e) =>
            name -> ScalTypeEvaluator.eval(e, inputResult.columns)
        }

    // logical output - map from the logical output names to their types
    private val resultTypes: Map[String, SqlType] =
        transformOp.transformer.outputColTypes(inTypes)

    // actual output columns
    val resultColumns: List[Column] = transformOp.out.map { case (name, col) =>
        Column(col.name, resultTypes(name))
    }

    override def rows: Iterator[ScalTableRow] = {
        val partn: List[ScalExpr] = transformOp.partn

        // check that input is sorted on (transformOp.partn, transformOp.order)
        val (compatible, rem) =
            inputResult.resultOrder.span { se => partn contains se.expr }
            
        if( !partn.diff(compatible.map { se => se.expr}).isEmpty ) {
            throw new IllegalArgumentException(
                "Input sort order is not compatible with partition"
            )
        }

        if( !SortExpr.isSubsumedBy(transformOp.order, rem) ) {
            throw new IllegalArgumentException(
                "Input sort order is not compatible with required order"
            )
        }

        val inputRows: Iterator[ScalTableRow] = inputResult.typedRows

        if( partn.isEmpty ) partnRows(Map(), inputRows) else {
            TableRowGroupIterator(evaluator, inputRows, partn).flatMap { g =>
                val partnMap: Map[String, ScalColValue] = g.groupColValMap.map {
                    case (ColRef(name), v) => name -> v
                    case (e, _) =>
                        throw new RuntimeException(
                            "Expecting a column, found " + e.repr
                        )
                }

                partnRows(partnMap, g.rows)
            }
        }
    }

    // takes care of combining the result and the input
    def partnRows(
        partnVals: Map[String, ScalColValue],
        inRows: Iterator[ScalTableRow]
    ): Iterator[ScalTableRow]

    // result, generated by transforming rows in a partn
    def partnTransform(
        inRows: Iterator[ScalTableRow]
    ): Iterator[ScalTableRow] = {
        // input name -> value map
        val inVals: Iterator[Map[String, ScalColValue]] = inRows.map { r =>
            Map() ++ transformOp.in.map { case (name, e) =>
                name -> evaluator.eval(e, r)
            }
        }

        // output name -> value map
        val outVals: Iterator[Map[String, ScalExpr]] =
            transformOp.transformer.transform(inTypes, inVals)

        outVals.map { outVal =>
            ScalTableRow(
                transformOp.out.map { case (name, col) =>
                    val expr: ScalExpr = ScalOpExpr(
                        TypeCast(resultTypes(name)), List(outVal(name))
                    )

                    col.name -> evaluator.eval(expr)
                }
            )
        }
    }

    override def close(): Unit = { }
}

sealed abstract class RetainTransformTableResult extends TransformTableResult {
    override val columns: List[Column] = inputResult.columns ::: resultColumns
}

case class JoinTransformTableResult(
    override val evaluator: ScalExprEvaluator,
    override val transformOp: JoinTransform,
    override val inputResult: TableResult
) extends RetainTransformTableResult {
    override val resultOrder: List[SortExpr] = inputResult.resultOrder

    override def partnRows(
        partnVals: Map[String, ScalColValue],
        inRows: Iterator[ScalTableRow]
    ): Iterator[ScalTableRow] = {
        val (inRowsA, inRowsB) = inRows.duplicate
        val resultRows: Iterator[ScalTableRow] = partnTransform(inRowsB)

        val zipRows: Iterator[(ScalTableRow, ScalTableRow)] = new OuterZip(
            inputResult.columns, inRowsA, resultColumns, resultRows
        )

        zipRows.map { case (r, outr) => ExtendedTableRow(r, outr) }
    }

    private class OuterZip(
        lhsCols: List[Column],
        lhs: Iterator[ScalTableRow],
        rhsCols: List[Column],
        rhs: Iterator[ScalTableRow]
    ) extends Iterator[(ScalTableRow, ScalTableRow)] {
        private val lhsNullRow: ScalTableRow = ScalTableRow(
            lhsCols.map { col => col.name -> SqlNull(col.sqlType) }
        )
        private val rhsNullRow: ScalTableRow = ScalTableRow(
            rhsCols.map { col => col.name -> SqlNull(col.sqlType) }
        )

        override def hasNext: Boolean = lhs.hasNext || rhs.hasNext
        override def next(): (ScalTableRow, ScalTableRow) =
            if( lhs.hasNext && rhs.hasNext ) (lhs.next(), rhs.next())
            else if( lhs.hasNext ) (lhs.next(), rhsNullRow)
            else if( rhs.hasNext ) (lhsNullRow, rhs.next())
            else Iterator.empty.next()
    }
}

case class UnionTransformTableResult(
    override val evaluator: ScalExprEvaluator,
    override val transformOp: Transform,
    override val inputResult: TableResult
) extends RetainTransformTableResult {
    override val resultOrder: List[SortExpr] = Nil

    private val nullResultRow: ScalTableRow = ScalTableRow(
        resultColumns.map { col => col.name -> SqlNull(col.sqlType) }
    )

    private def partnValRow(
        partnVals: Map[String, ScalColValue]
    ): ScalTableRow = ScalTableRow(
        Map() ++ inputResult.columns.map { col =>
            col.name -> SqlNull(col.sqlType)
        } ++ partnVals
    )

    override def partnRows(
        partnVals: Map[String, ScalColValue],
        inRows: Iterator[ScalTableRow]
    ): Iterator[ScalTableRow] = {
        val (inRowsA, inRowsB) = inRows.duplicate

        val extInRows: Iterator[ScalTableRow] =
            inRowsA.map { inRow => ExtendedTableRow(inRow, nullResultRow) }

        val resultRows: Iterator[ScalTableRow] = partnTransform(inRowsB)

        val partnRow: ScalTableRow = partnValRow(partnVals)
        val extResultRows: Iterator[ScalTableRow] =
            resultRows.map { resRow => ExtendedTableRow(resRow, partnRow) }

        extInRows ++ extResultRows
    }
}

object TransformTableResult {
    def apply(
        evaluator: ScalExprEvaluator,
        transformOp: Transform,
        inputResult: TableResult
    ): TransformTableResult = transformOp match {
        case (joinTrans: JoinTransform) =>
            JoinTransformTableResult(evaluator, joinTrans, inputResult)
        case (unionTrans: UnionTransform) =>
            UnionTransformTableResult(evaluator, unionTrans, inputResult)
    }
}
